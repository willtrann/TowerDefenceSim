<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Monster.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">scaffold</a> &gt; <a href="index.source.html" class="el_package">WizardTD</a> &gt; <span class="el_source">Monster.java</span></div><h1>Monster.java</h1><pre class="source lang-java linenums">package WizardTD;
import processing.core.PImage;

import java.util.*;
import java.io.*;

/**
 * The type Monster.
 */
public class Monster {
    /**
     * The Type.
     */
    private PImage type;
    /**
     * The Hp.
     */
    private double hp;
    /**
     * The Initial hp.
     */
    public double initial_hp;
    /**
     * The Speed.
     */
    private float speed;
    /**
     * The Armour.
     */
    private double armour;
    /**
     * The Mana gained on kill.
     */
    private int mana_gained_on_kill;
    /**
     * The X pos.
     */
    private float X_Pos;
    /**
     * The Y pos.
     */
    private float Y_Pos;
    /**
     * If monster has first spawned.
     */
    private boolean firstSpawned;

    /**
     * The Monster imgs.
     */
    private List&lt;PImage&gt; monster_imgs;
    /**
     * The Visited.
     */
    private boolean[][] visited;
    /**
     * The Path.
     */
    private List&lt;Coordinate&gt; path;
    /**
     * The Initial path.
     */
    private List&lt;Coordinate&gt; initial_path;
    /**
     * The Is dying.
     */
<span class="fc" id="L67">    private boolean isDying = false;</span>

    /**
     * The Slowed.
     */
<span class="fc" id="L72">    public boolean slowed = false;</span>

    /**
     * The Monster frame count.
     */
<span class="fc" id="L77">    public int MonsterFrameCount = 0;</span>

    /**
     * Instantiates a new Monster.
     *
     * @param monster_imgs        the monster imgs
     * @param hp                  the hp
     * @param speed               the speed
     * @param armour              the armour
     * @param mana_gained_on_kill the mana gained on kill
     */
<span class="fc" id="L88">    public Monster(List&lt;PImage&gt; monster_imgs, double hp, float speed, double armour, int mana_gained_on_kill){</span>
<span class="fc" id="L89">        this.monster_imgs = monster_imgs;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if(monster_imgs.isEmpty()) {</span>
<span class="fc" id="L91">            this.type = null;</span>
        }
        else {
<span class="fc" id="L94">            this.type = monster_imgs.get(0);</span>
        }
<span class="fc" id="L96">        this.hp = this.initial_hp = hp;</span>
<span class="fc" id="L97">        this.speed = speed;</span>
<span class="fc" id="L98">        this.armour = armour;</span>
<span class="fc" id="L99">        this.mana_gained_on_kill = mana_gained_on_kill;</span>
<span class="fc" id="L100">        this.firstSpawned = true;</span>
<span class="fc" id="L101">    }</span>

    /**
     * Gets type.
     *
     * @return the type
     */
    public PImage getType() {
<span class="fc" id="L109">        return type;</span>
    }

    /**
     * Gets hp.
     *
     * @return the hp
     */
    public double getHp() {
<span class="fc" id="L118">        return hp;</span>
    }

    /**
     * Gets armour.
     *
     * @return the armour
     */
    public double getArmour() {
<span class="fc" id="L127">        return armour;</span>
    }

    /**
     * Gets speed.
     *
     * @return the speed
     */
    public float getSpeed() {
<span class="fc" id="L136">        return speed;</span>
    }

    /**
     * Gets mana gained on kill.
     *
     * @return the mana gained on kill
     */
    public int getMana_gained_on_kill() {
<span class="fc" id="L145">        return mana_gained_on_kill;</span>
    }

    /**
     * Get x pos float.
     *
     * @return the float
     */
    public float getX_Pos(){
<span class="fc" id="L154">        return this.X_Pos;</span>
    }

    /**
     * Get y pos float.
     *
     * @return the float
     */
    public float getY_Pos(){
<span class="fc" id="L163">        return this.Y_Pos;</span>
    }

    /**
     * Dying animation, returns determines if no more images to animate.
     *
     * @return the boolean
     */
    public boolean dyingAnimation(){
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if(monster_imgs.isEmpty()){</span>
<span class="fc" id="L173">            return true; // if fully dead</span>
        }
        else{
<span class="fc" id="L176">            monster_imgs.remove(0);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (monster_imgs.isEmpty()) {</span>
<span class="fc" id="L178">                return true; // if fully dead</span>
            } else {
<span class="fc" id="L180">                type = monster_imgs.get(0); // get new image of monster death animation</span>
            }
        }
<span class="fc" id="L183">        return false;</span>
    }

    /**
     * Update position of monster on map.
     */
    public void updatePosition() {
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (path.isEmpty()) {</span>
<span class="fc" id="L191">            return; // if path is empty, dont move</span>
        }

<span class="fc" id="L194">        Coordinate target = path.get(0); // get the next target from path</span>
<span class="fc" id="L195">        float targetX = target.x * 32 + 5; // get next coordinate monster moves to</span>
<span class="fc" id="L196">        float targetY = target.y * 32 + 45;</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">        if(firstSpawned){</span>
<span class="fc" id="L199">            X_Pos = targetX; // if first spawned, draw start position</span>
<span class="fc" id="L200">            Y_Pos = targetY;</span>
<span class="fc" id="L201">            firstSpawned = false;</span>
<span class="fc" id="L202">            return;</span>
        }

        int directionX;
        int directionY;

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (X_Pos &lt; targetX) {</span>
<span class="fc" id="L209">            directionX = 1; // get direction monster should move in x or y direction</span>
        } else {
<span class="fc" id="L211">            directionX = -1;</span>
        }

<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (Y_Pos &lt; targetY) {</span>
<span class="fc" id="L215">            directionY = 1;</span>
        } else {
<span class="fc" id="L217">            directionY = -1;</span>
        }

<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (X_Pos != targetX) {</span>
<span class="fc" id="L221">            X_Pos += directionX * speed; // if monster not reached target, move towards</span>
<span class="fc bfc" id="L222" title="All 8 branches covered.">            if ((directionX == 1 &amp;&amp; X_Pos &gt; targetX) || (directionX == -1 &amp;&amp; X_Pos &lt; targetX)) {</span>
<span class="fc" id="L223">                X_Pos = targetX; // if monster pretty much at target, set to target</span>
            }
        }

<span class="fc bfc" id="L227" title="All 2 branches covered.">        else if (Y_Pos != targetY) {</span>
<span class="fc" id="L228">            Y_Pos += directionY * speed; // if monster not reached target, move towards</span>
<span class="pc bpc" id="L229" title="4 of 8 branches missed.">            if ((directionY == 1 &amp;&amp; Y_Pos &gt; targetY) || (directionY == -1 &amp;&amp; Y_Pos &lt; targetY)) {</span>
<span class="fc" id="L230">                Y_Pos = targetY;  // if monster pretty much at target, set to target</span>
            }
        }

<span class="fc bfc" id="L234" title="All 4 branches covered.">        if (X_Pos == targetX &amp;&amp; Y_Pos == targetY) {</span>
<span class="fc" id="L235">            removeFirstElement(); // if at x and y position of target coordinate, remove it from path list.</span>
        }
<span class="fc" id="L237">    }</span>

    /**
     * Reset path.
     */
    public void resetPath(){
<span class="fc" id="L243">        path = new ArrayList&lt;&gt;(initial_path); // reset path and set to initial entrance of path</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if(!initial_path.isEmpty()) {</span>
<span class="fc" id="L245">            X_Pos = initial_path.get(0).x * 32 + 5;</span>
<span class="fc" id="L246">            Y_Pos = initial_path.get(0).y * 32 + 45;</span>
        }
<span class="fc" id="L248">    }</span>

    /**
     * Take damage.
     *
     * @param dmg the dmg
     */
    public void takeDamage(double dmg){
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if(this.hp &gt; 0){</span>
<span class="fc" id="L257">            this.hp -= dmg * (1.0 - this.armour); // take damage based on armour</span>
        }
<span class="fc" id="L259">    }</span>

    /**
     * Get path of monster.
     *
     * @return the list
     */
    public List&lt;Coordinate&gt; getPath(){
<span class="fc" id="L267">        return this.path;</span>
    }

    /**
     * Set x pos.
     *
     * @param x the x
     */
    public void setX_Pos(float x){
<span class="fc" id="L276">        this.X_Pos = x;</span>
<span class="fc" id="L277">    }</span>

    /**
     * Set y pos.
     *
     * @param y the y
     */
    public void setY_Pos(float y){
<span class="fc" id="L285">        this.Y_Pos = y;</span>
<span class="fc" id="L286">    }</span>

    /**
     * Is dead boolean.
     *
     * @return the boolean
     */
    public boolean isDead(){
<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (this.hp &lt;= 0){</span>
<span class="fc" id="L295">            isDying = true;</span>
<span class="fc" id="L296">            return true; // returns if dead or not</span>
        };
<span class="fc" id="L298">        return false;</span>
    }

    /**
     * Slow monster.
     *
     * @param rate the rate
     */
    public void slowMonster(double rate){
<span class="fc" id="L307">        slowed = true;</span>
<span class="fc" id="L308">        speed *= (float) (1-rate); // slows monster based on rate of slow</span>
<span class="fc" id="L309">    }</span>

    /**
     * Set path.
     *
     * @param entrance the entrance
     * @param f        the f
     */
    public void setPath(Coordinate entrance, File f){
        try {
<span class="fc" id="L319">            Scanner scan = new Scanner(f);</span>
<span class="fc" id="L320">            ArrayList&lt;String&gt; map_points = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            while (scan.hasNextLine()) {</span>
<span class="fc" id="L322">                map_points.add(scan.nextLine());</span>
            }

<span class="fc" id="L325">            int height = map_points.size();</span>

<span class="fc" id="L327">            int maxWidth = 0;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">            for (String line : map_points) {</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">                if (line.length() &gt; maxWidth) {</span>
<span class="fc" id="L330">                    maxWidth = line.length();</span>
                }
<span class="fc" id="L332">            }</span>
            // get map

<span class="fc" id="L335">            visited = new boolean[maxWidth][height]; // boolean of visited cells true or false</span>

<span class="fc" id="L337">            initial_path = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L338">            dfs( (int) entrance.x, (int) entrance.y, map_points); // implement depth first search algorithm to find end</span>
<span class="fc" id="L339">            path = new ArrayList&lt;&gt;(initial_path); // path = initial path;</span>

<span class="fc" id="L341">        } catch(FileNotFoundException e){</span>
<span class="fc" id="L342">            System.out.println(&quot;File not found!&quot;);</span>
<span class="fc" id="L343">        }</span>


<span class="fc" id="L346">    }</span>

    /**
     * Dfs boolean through recursion.
     *
     * @param x          the x
     * @param y          the y
     * @param map_points the map points
     * @return the boolean value of path
     */
    public boolean dfs(int x, int y, List&lt;String&gt; map_points) {
<span class="pc bpc" id="L357" title="4 of 8 branches missed.">        if(x &lt; 0 || y &lt; 0 || y &gt;= map_points.size() || x &gt;= map_points.get(0).length()) {</span>
<span class="nc" id="L358">            return false; // Out of the map</span>
        }

<span class="fc" id="L361">        char cell = map_points.get(y).charAt(x); // cell</span>

        // Check if the cell is not 'X', or it's already visited
<span class="fc bfc" id="L364" title="All 6 branches covered.">        if((cell != 'X' &amp;&amp; cell != 'W') || visited[x][y]) {</span>
<span class="fc" id="L365">            return false; // Not a valid cell to traverse or already visited, return false.</span>
        }

        // Mark the cell as visited
<span class="fc" id="L369">        visited[x][y] = true;</span>

        // Add the current cell to the path
<span class="fc" id="L372">        initial_path.add(new Coordinate(x, y));</span>

        // Check if the current cell is 'W'
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if(cell == 'W') {</span>
<span class="fc" id="L376">            return true; // 'W' found, return true.</span>
        }

        // Perform the DFS in all valid directions and check if 'W' is found in any direction
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if(dfs(x + 1, y, map_points) // Right</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">                || dfs(x - 1, y, map_points) // Left</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                || dfs(x, y + 1, map_points) // Down</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                || dfs(x, y - 1, map_points)) { // Up</span>
<span class="fc" id="L384">            return true; // 'W' found in one of the directions, return true.</span>
        }

        // If 'W' is not found in any direction from the current cell, remove the current cell from the path and backtrack
<span class="fc" id="L388">        initial_path.remove(initial_path.size() - 1);</span>

<span class="fc" id="L390">        return false; // Return false as 'W' is not found in any direction from the current cell.</span>
    }

    /**
     * Remove first element of path.
     */
    public void removeFirstElement(){
<span class="fc" id="L397">        this.path.remove(0);</span>
<span class="fc" id="L398">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>